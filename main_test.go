package main

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	datasetsv1 "github.com/tilebox/tilebox-go/protogen/datasets/v1"
	"google.golang.org/protobuf/reflect/protodesc"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/known/durationpb"
	"google.golang.org/protobuf/types/known/timestamppb"
	"google.golang.org/protobuf/types/pluginpb"
)

func Test_generateCode(t *testing.T) {
	type args struct {
		req *pluginpb.CodeGeneratorRequest
	}
	tests := []struct {
		name    string
		args    args
		want    *pluginpb.CodeGeneratorResponse
		wantErr string
	}{
		{
			name: "generateCode",
			args: args{
				req: &pluginpb.CodeGeneratorRequest{
					FileToGenerate: []string{"Dataset.proto"},
					ProtoFile: []*descriptorpb.FileDescriptorProto{
						protodesc.ToFileDescriptorProto(timestamppb.File_google_protobuf_timestamp_proto),
						protodesc.ToFileDescriptorProto(durationpb.File_google_protobuf_duration_proto),
						protodesc.ToFileDescriptorProto(datasetsv1.File_datasets_v1_well_known_types_proto),
						{
							Name:       pointer("Dataset.proto"),
							Dependency: []string{"datasets/v1/well_known_types.proto"},
							MessageType: []*descriptorpb.DescriptorProto{
								{
									Name: pointer("Dataset"),
									Field: []*descriptorpb.FieldDescriptorProto{
										{
											Name:   pointer("id"),
											Number: pointer[int32](1),
											Label:  pointer(descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL),
											Type:   pointer(descriptorpb.FieldDescriptorProto_TYPE_STRING),
										},
										{
											Name:     pointer("nested_message"),
											Number:   pointer[int32](2),
											Label:    pointer(descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL),
											Type:     pointer(descriptorpb.FieldDescriptorProto_TYPE_MESSAGE),
											TypeName: pointer(".datasets.v1.Vec3"),
										},
									},
								},
							},
							Options: &descriptorpb.FileOptions{
								GoPackage: pointer("tilebox/v1"),
							},
							Syntax:  pointer("editions"),
							Edition: pointer(descriptorpb.Edition_EDITION_2023),
						},
					},
				},
			},
			want: &pluginpb.CodeGeneratorResponse{
				File: []*pluginpb.CodeGeneratorResponse_File{
					{
						Name: pointer("tilebox/v1/Dataset.pb.go"),
					},
				},
			},
		},
		{
			name: "generateCode colliding field numbers",
			args: args{
				req: &pluginpb.CodeGeneratorRequest{
					FileToGenerate: []string{"Dataset.proto"},
					ProtoFile: []*descriptorpb.FileDescriptorProto{
						{
							Name:       pointer("Dataset.proto"),
							Dependency: nil,
							MessageType: []*descriptorpb.DescriptorProto{
								{
									Name: pointer("Dataset"),
									Field: []*descriptorpb.FieldDescriptorProto{
										{
											Name:   pointer("id"),
											Number: pointer[int32](1),
											Label:  pointer(descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL),
											Type:   pointer(descriptorpb.FieldDescriptorProto_TYPE_STRING),
										},
										{
											Name:   pointer("id2"),
											Number: pointer[int32](1),
											Label:  pointer(descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL),
											Type:   pointer(descriptorpb.FieldDescriptorProto_TYPE_STRING),
										},
									},
								},
							},
							Options: &descriptorpb.FileOptions{
								GoPackage: pointer("tilebox/v1"),
							},
							Syntax:  pointer("editions"),
							Edition: pointer(descriptorpb.Edition_EDITION_2023),
						},
					},
				},
			},
			wantErr: "failed to create generator",
		},
		{
			name: "generateCode missing file",
			args: args{
				req: &pluginpb.CodeGeneratorRequest{
					FileToGenerate: []string{"Dataset.proto"},
					ProtoFile:      []*descriptorpb.FileDescriptorProto{},
				},
			},
			wantErr: "failed to validate request",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := generateCode(tt.args.req)
			if tt.wantErr != "" {
				// we wanted an error, let's check if we got one
				require.Error(t, err, "expected an error, got none")
				assert.Contains(t, err.Error(), tt.wantErr, "error didn't contain expected message: '%s', got error '%s' instead.", tt.wantErr, err.Error())
				return
			}
			// we didn't want an error:
			require.NoError(t, err, "got an unexpected error")

			assert.Len(t, got.GetFile(), 1)
			gotFile := got.GetFile()[0]
			assert.Equal(t, tt.want.GetFile()[0].GetName(), gotFile.GetName())
			assert.Contains(t, gotFile.GetContent(), "// Code generated by protoc-gen-go.")
			assert.Contains(t, gotFile.GetContent(), "package v1")
			assert.Contains(t, gotFile.GetContent(), "type Dataset struct {")
			assert.Contains(t, gotFile.GetContent(), "Id            *string                `protobuf:\"bytes,1,opt,name=id\" json:\"id,omitempty\"`")
		})
	}
}
